# 线性基
是向量空间的一组基，即是有一个集合构造出来的另一个集合，用来解决有关异或题目
满足以下性质
 - 线性基内元素相互异或可以得到原序列相互异或得到的值
 - 线性基没有异或为0的子集
 - 线性基每个元素的异或方案唯一
 - 线性基的每个元素的最高位互不相同

### 构造方法
把每个数x转为二进制，从高到低，若该位为1，如果线性基该位为空，那么赋值并结束循环；否则将该数x更改为x^=p[i]，继续循环。

```
int p[maxn];
void insert(ll x) {
	for (int i = 63; i >= 0; --i) {
		if (!(x >> i))
			continue;
		if (!p[i]) {
			p[i] = x;
			break;
		}
		x ^= p[i];
	}
}
```
### 解决问题

 1. 求原集合内任意元素异或给定值的最大值

> 从高位到低位，若该位的数异或上答案能使答案变大则异或上该值
> 因为线性基的每位最多一个为1，所以从高到低可以保证低位不对高位的异或结果产生影响

2. 求原集合任意元素异或后的最小值

> 答案就是线性基中的最小值

3. 求某个数能否被原集合异或出来
> 即插入操作，判断最后的x是否被异或为0

### 例题
luogu p3857
一排n个灯，每个灯有亮和不亮的状态，初始全不亮；有m个开关可以控制一些灯，求灯能形成的不同状态数（模2008）

> 相当于m个开关造成的二进制数能异或出来多少种不同的结果
> 求出m个开关造成的状态数的线性基，求出线性基内的数的个数，答案即为$2^{size}$

```
const int maxn = 50 + 2;
const ll mod = 2008;
bitset<maxn> p[maxn];
char str[maxn];
int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);

	int n, m; cin >> n >> m;
	int ans = 0;
	for (int i = 0; i < m; ++i) {
		cin >> str;
		bitset<maxn> t; t.reset();
		for (int j = 0; j < n; ++j) {
			if (str[j] == 'O')
				t[j] = 1;
			else
				t[j] = 0;
		}
		for (int j = 0; j < n; ++j) {
			if (t[j] && p[j].count())
				t = t ^ p[j];
			else if (t[j]) {
				p[j] = t;
				ans++;
				break;
			}
		}
	}
	
	cout << (1ll << ans) % 2008 << '\n';
}
```

